<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–æ—à—Ç–æ–º–∞—Ç–µ—Ä</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        .map-floating-logo {
            position: absolute; /* –í—ã—Ä—ã–≤–∞–µ–º –∏–∑ –ø–æ—Ç–æ–∫–∞ */
            bottom: 25px;       /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É */
            right: 25px;        /* –û—Ç—Å—Ç—É–ø —Å–ø—Ä–∞–≤–∞ */
            
            width: 80px;       /* –†–∞–∑–º–µ—Ä –ª–æ–≥–æ—Ç–∏–ø–∞ (–ø–æ–ø—Ä–∞–≤—å—Ç–µ –ø–æ–¥ —Å–µ–±—è) */
            height: auto;       /* –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ */
            
            z-index: 5000;      /* –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π –∏–Ω–¥–µ–∫—Å, —á—Ç–æ–±—ã –±—ã—Ç—å –≤—ã—à–µ –∫–∞—Ä—Ç—ã */
            
            opacity: 0.7;       /* –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å (50%), —á—Ç–æ–±—ã –Ω–µ –æ—Ç–≤–ª–µ–∫–∞—Ç—å */
            
            /* –°–ê–ú–û–ï –í–ê–ñ–ù–û–ï: */
            pointer-events: none; /* –õ–æ–≥–æ—Ç–∏–ø –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç –∫–ª–∏–∫–∏ —Å–∫–≤–æ–∑—å —Å–µ–±—è –Ω–∞ –∫–∞—Ä—Ç—É */
            
            transition: opacity 0.3s ease; /* –ü–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) */
        }
        .map-floating-logo:hover {
            opacity: 1; 
        }
        :root {
            --bg-body: #0f172a;       
            --bg-sidebar: #1e293b;    
            --bg-card: #334155;       
            --bg-hover: #475569;      
            --text-main: #f1f5f9;     
            --text-muted: #94a3b8;
            --border: #334155;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Inter', sans-serif; 
            display: flex; height: 100vh; 
            color: var(--text-main);
            background: var(--bg-body);
        }
        
        #sidebar {
            width: 340px;
            flex-shrink: 0; 
            background: var(--bg-sidebar);
            padding: 20px; 
            border-right: 1px solid #1e293b;
            display: flex; flex-direction: column; gap: 15px; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 1000;
            overflow-y: auto; height: 100vh;
            box-sizing: border-box; 
        }

        h2 { margin: 0; font-size: 1.1rem; text-transform: uppercase; letter-spacing: 1.2px; color: var(--text-main); font-weight: 700; }

        .card { background: #1e293b; border: 1px solid var(--border); border-radius: 6px; padding: 15px; }

        label { display: block; margin-bottom: 8px; font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }

        input[type="number"], input[type="file"] {
            width: 100%; box-sizing: border-box; padding: 10px;
            background: var(--bg-body); border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px;
            font-family: inherit; outline: none; transition: border-color 0.2s;
        }
        input[type="number"]:focus { border-color: #64748b; }

        .file-wrapper {
            position: relative; overflow: hidden;
            background: var(--bg-body); border: 1px dashed var(--text-muted);
            border-radius: 4px; padding: 15px; text-align: center; cursor: pointer;
            transition: all 0.2s;
        }
        .file-wrapper:hover { border-color: var(--text-main); background: #182235; }
        .file-wrapper input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor:pointer; }
        #fileName { font-size: 0.85rem; color: var(--text-muted); pointer-events: none;}

        button {
            width: 100%; padding: 12px; margin-top: 10px;
            background-color: var(--bg-card); border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px; cursor: pointer;
            font-size: 0.9rem; font-weight: 500; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.2;
        }
        button:hover { background-color: var(--bg-hover); border-color: #64748b; }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #1e293b; color: #64748b; }
        button.small-btn { margin-top: 0; padding: 6px 10px; font-size: 0.75rem; width: auto; background: #1e293b; }

        .status { font-size: 0.8rem; color: var(--text-muted); margin-top: 10px; }
        .status-ok { color: #4ade80; }

        #map { flex-grow: 1; height: 100%; background: #0f172a; }

        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: var(--bg-sidebar); color: var(--text-main);
            border: 1px solid var(--border); box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .leaflet-popup-content { margin: 15px; line-height: 1.6; }
        .popup-row { display: flex; gap: 5px; margin-top: 8px; align-items: center; }
        
        .group-label {
            background: #747272b9; border: 2px solid var(--text-main);
            color: var(--text-main); border-radius: 50%;
            text-align: center; font-weight: bold; font-size: 12px; line-height: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); cursor: help;
        }
        
        .selected-marker {
            border: 2px solid #facc15 !important; transform: scale(1.3);
            box-shadow: 0 0 10px #facc15; z-index: 1000 !important;
        }

        #bulkActions {
            display: none; background: #334155; padding: 10px;
            border-radius: 4px; margin-top: 10px; border: 1px solid #facc15;
        }

        .setting-row { display: flex; gap: 10px; margin-bottom: 5px; }
        .setting-col { flex: 1; }

        @media (max-width: 800px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-right: none; border-bottom: 1px solid #1e293b; }
            #map { width: 100%; height: 60vh; }
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background-color: #334155; border-radius: 4px; border: 2px solid #0f172a; }
        ::-webkit-scrollbar-thumb:hover { background-color: #475569; }

        select {
            width: 100%; padding: 10px; background: var(--bg-body); border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px; cursor: pointer; margin-bottom: 5px;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>–†–æ–∑–∫–∏–¥–∞—á –ø–æ—à—Ç–æ–º–∞—Ç—ñ–≤</h2>
    
    <div class="card">
        <label>1. –î–∞–Ω—ñ (.xlsx)</label>
        <div class="file-wrapper">
            <input type="file" id="fileInput" accept=".xlsx, .xls">
            <div id="fileName">–û–±—Ä–∞—Ç–∏ —Ñ–∞–π–ª</div>
        </div>
        <div id="fileStatus" class="status">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è...</div>
    </div>

    <div class="card">
        <label>2. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</label>
        
        <label style="margin-top:10px; margin-bottom:5px; color:#94a3b8;">–ê–ª–≥–æ—Ä–∏—Ç–º:</label>
        <select id="algoSelect">
            <option value="greedy">–°—É–≤–æ—Ä–∏–π –ª—ñ–º—ñ—Ç (–ñ–∞–¥—ñ–±–Ω–∏–π)</option>
            <option value="kmeans">–ë–∞–ª–∞–Ω—Å (K-Means)</option>
        </select>

        <div class="setting-row">
            <div class="setting-col">
                <div style="font-size:0.75rem; color:#94a3b8; margin-bottom:3px;">–ú–∞–∫—Å —Ç–æ—á–æ–∫:</div>
                <input type="number" id="maxCapacity" value="50" min="1" step="5">
            </div>
            <div class="setting-col">
                <div style="font-size:0.75rem; color:#94a3b8; margin-bottom:3px;">–ú–∞–∫—Å –≤–∞–≥–∞:</div>
                <input type="number" id="maxLoad" value="500" min="1" step="50">
            </div>
        </div>
        
        <button onclick="calculateDistribution()">–ü—ñ–¥—Ä–∞—Ö—É–π</button>
    </div>

    <div class="card">
        <label>–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏</label>
        
        <button id="undoBtn" onclick="undoLastAction()" disabled style="background-color: #475569; border: 1px dashed #94a3b8; color: #f1f5f9;">
            ‚Ü© –°–∫–∞—Å—É–≤–∞—Ç–∏ –¥—ñ—é
        </button>

        <hr style="border-color:#334155; margin: 15px 0;">

        <button id="btnSelectMode" onclick="toggleSelectionMode()">–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è</button>
        
        <div id="bulkActions">
            <label style="color:#facc15;">–û–±—Ä–∞–Ω–æ —Ç–æ—á–æ–∫: <span id="selCount">0</span></label>
            <div style="margin-bottom:5px; font-size:0.75rem;">–ù–æ–≤–∞ –≥—Ä—É–ø–∞:</div>
            <div style="display:flex; gap:5px;">
                <input type="number" id="bulkGroupInput" placeholder="‚Ññ" style="width: 60px;" min="-50">
                <button class="small-btn" onclick="moveSelectedPoints()" style="background:#0f172a;">OK</button>
            </div>
            <button class="small-btn" onclick="clearSelection()" style="width:100%; margin-top:5px; border-color: #ef4444; color:#ef4444;">–°–∫–∞—Å—É–≤–∞—Ç–∏ –≤–∏–±—ñ—Ä</button>
        </div>

        <button onclick="redrawMap()" style="margin-top:15px">–û–Ω–æ–≤–∏—Ç–∏ –º–∞–ø—É</button>
        <button onclick="exportToExcel()" style="border-color: #4ade80; color: #4ade80;">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
    </div>
    
</div>

<div id="map"></div>
<img src="logo3.png" alt="Logo" class="map-floating-logo">
<script>
    let map;
    let hubsData = [];
    let pointsData = [];
    let layers = {
        hubs: L.layerGroup(),
        points: L.layerGroup(),
        polygons: L.layerGroup(),
        labels: L.layerGroup()
    };
    let selectionMode = false;
    let selectedIds = new Set();
    let historyStack = [];
    const MAX_HISTORY = 20;

    function initMap() {
        map = L.map('map', {zoomControl: false}).setView([50.4501, 30.5234], 11);
        L.control.zoom({ position: 'topright' }).addTo(map);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(map);
        layers.polygons.addTo(map);
        layers.hubs.addTo(map);
        layers.points.addTo(map);
        layers.labels.addTo(map);
    }
    initMap();

    // --- FILE PROCESSING ---
    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('fileName').innerText = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {type: 'array'});
                if (wb.SheetNames.includes("Saved_Points") && wb.SheetNames.includes("Saved_Hubs")) {
                    restoreWork(wb);
                } else {
                    parseNewFile(wb);
                }
            };
            reader.readAsArrayBuffer(file);
        }
    });

    function parseNewFile(wb) {
        const names = wb.SheetNames;
        let hName = names.find(n => n.toLowerCase().includes('—Å–ª—É–∂–±') || n.toLowerCase().includes('hubs')) || names[0];
        let pName = names.find(n => n.toLowerCase().includes('–ø–æ—à—Ç') || n.toLowerCase().includes('points')) || names[1] || names[0];
        const hRaw = XLSX.utils.sheet_to_json(wb.Sheets[hName]);
        const pRaw = XLSX.utils.sheet_to_json(wb.Sheets[pName]);
        processData(hRaw, pRaw, false);
    }

    function restoreWork(wb) {
        const hRaw = XLSX.utils.sheet_to_json(wb.Sheets["Saved_Hubs"]);
        const pRaw = XLSX.utils.sheet_to_json(wb.Sheets["Saved_Points"]);
        hubsData = hRaw.map(h => ({ id: h.id, lat: h.lat, lng: h.lng }));
        pointsData = pRaw.map(p => ({
            id: p.id, lat: p.lat, lng: p.lng,
            assignedHub: p.assignedHub, groupIndex: p.groupIndex, 
            color: p.color,
            load: p.load || 0 // Restore load
        }));
        historyStack = []; updateUndoUI();
        drawHubs(); drawPoints(); drawBoundaries();
        const statusEl = document.getElementById('fileStatus');
        statusEl.innerHTML = "–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ! <span class='status-ok'>‚úî Saved</span>";
        statusEl.classList.add('status-ok');
    }

    function processData(hRaw, pRaw, isRestored) {
        if(!isRestored) {
            hubsData = hRaw.filter(r => r['–®–∏—Ä–æ—Ç–∞']).map(h => ({
                id: h['–°–∫–ª–∞–¥'] || h['–ù–∞–∑–≤–∞–Ω–∏–µ'] || h['ID'] || 'Unknown',
                lat: parseFloat(h['–®–∏—Ä–æ—Ç–∞']), lng: parseFloat(h['–î–æ–≤–≥–æ—Ç–∞'])
            }));

            // Detect Load Column
            if (pRaw.length > 0) {
                const keys = Object.keys(pRaw[0]);
                // regex look for: –≤–∞–≥–∞, weight, kg, –∫–≥, volume, –æ–±—ä–µ–º, load, –≥—Ä—É–∑
                var loadKey = keys.find(k => /–≤–∞–≥–∞|weight|–∫–≥|kg|–æ–±'?—î–º|vol|–≥—Ä—É–∑|load/i.test(k));
                console.log("Load column detected:", loadKey);
            }

            pointsData = pRaw.filter(r => r['–®–∏—Ä–æ—Ç–∞']).map(p => ({
                id: p['–°–∫–ª–∞–¥'] || p['ID'] || 'Unknown',
                lat: parseFloat(p['–®–∏—Ä–æ—Ç–∞']), lng: parseFloat(p['–î–æ–≤–≥–æ—Ç–∞']),
                assignedHub: null, groupIndex: 0, color: '#475569',
                load: loadKey ? (parseFloat(p[loadKey]) || 0) : 0
            }));
        }
        historyStack = []; updateUndoUI();
        
        let totalLoad = pointsData.reduce((acc, p) => acc + p.load, 0);
        document.getElementById('fileStatus').innerText = `–¢: ${pointsData.length} | –í–∞–≥–∞: ${totalLoad.toFixed(0)}`;
        document.getElementById('fileStatus').classList.remove('status-ok');
        drawHubs(); drawPoints();
    }

    // --- ALGORITHMS ---
    function calculateDistribution() {
        if(!hubsData.length) return alert('–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª!');
        saveState(); 

        const maxPts = parseInt(document.getElementById('maxCapacity').value) || 50;
        const maxLoad = parseInt(document.getElementById('maxLoad').value) || 100000;
        const algo = document.getElementById('algoSelect').value;

        // Reset & Link
        pointsData.forEach(p => {
            let nearest = null, min = Infinity;
            const pt = turf.point([p.lng, p.lat]);
            hubsData.forEach(h => {
                const d = turf.distance(pt, turf.point([h.lng, h.lat]));
                if(d < min) { min = d; nearest = h.id; }
            });
            p.assignedHub = nearest;
            p.groupIndex = 0; 
        });

        hubsData.forEach(h => {
            let hubPoints = pointsData.filter(p => p.assignedHub === h.id);
            if (!hubPoints.length) return;
            if (algo === 'greedy') applyGreedyAlgo(h, hubPoints, maxPts, maxLoad);
            else applyKMeansAlgo(h, hubPoints, maxPts, maxLoad);
        });
        redrawMap();
    }

    function applyKMeansAlgo(hub, pts, maxPts, maxLoad) {
        // Calculate needed clusters based on BOTH constraints
        const totalLoad = pts.reduce((sum, p) => sum + p.load, 0);
        const kLoad = Math.ceil(totalLoad / maxLoad);
        const kCount = Math.ceil(pts.length / maxPts);
        
        // Take the larger requirement
        const k = Math.max(kLoad, kCount);

        if(k <= 1) {
            const col = getDistinctColor(1);
            pts.forEach(p => { p.groupIndex = 1; p.color = col; });
        } else {
            const fc = turf.featureCollection(pts.map(p => turf.point([p.lng, p.lat], {oid: p.id})));
            const clustered = turf.clustersKmeans(fc, {numberOfClusters: k});
            const mapCol = {}; let localC = 0;
            clustered.features.forEach(f => {
                const cid = f.properties.cluster; 
                if(!mapCol[cid]) { localC++; mapCol[cid] = getDistinctColor((hub.id.length + localC) * 5); }
                const p = pts.find(x => x.id === f.properties.oid);
                if(p) { p.groupIndex = cid + 1; p.color = mapCol[cid]; }
            });
        }
    }

    function applyGreedyAlgo(hub, pts, maxPts, maxLoad) {
        let pool = [...pts]; let gCounter = 1;
        const hubPt = turf.point([hub.lng, hub.lat]);
        
        while(pool.length > 0) {
            // Find farthest
            let farthestPt = pool[0]; let maxDist = -1;
            pool.forEach(p => {
                const d = turf.distance(hubPt, turf.point([p.lng, p.lat]));
                if(d > maxDist) { maxDist = d; farthestPt = p; }
            });
            
            // Sort by distance to farthest
            const anchorGeo = turf.point([farthestPt.lng, farthestPt.lat]);
            const withDist = pool.map(p => ({ p: p, d: turf.distance(anchorGeo, turf.point([p.lng, p.lat])) }));
            withDist.sort((a, b) => a.d - b.d);
            
            // Fill Chunk honoring BOTH limits
            let currentChunk = [];
            let currentCount = 0;
            let currentLoad = 0;
            
            for (let i = 0; i < withDist.length; i++) {
                const cand = withDist[i].p;
                // Check limits. Always add at least one point even if it exceeds limit (to avoid infinite loop)
                if (currentCount === 0 || 
                   (currentCount + 1 <= maxPts && currentLoad + cand.load <= maxLoad)) {
                    currentChunk.push(cand);
                    currentCount++;
                    currentLoad += cand.load;
                }
            }

            const chunkIds = new Set(currentChunk.map(x => x.id));
            const col = getDistinctColor((hub.id.length + gCounter) * 7);
            currentChunk.forEach(p => { p.groupIndex = gCounter; p.color = col; });
            
            pool = pool.filter(p => !chunkIds.has(p.id));
            gCounter++;
        }
    }

    // --- DRAWING & UI ---
    function drawHubs() {
        layers.hubs.clearLayers();
        const icon = L.divIcon({
            className: '',
            html: "<div style='background:#0f172a; color:#fff; width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center; border:2px solid #fff; font-weight:bold;'>H</div>",
            iconSize: [28,28]
        });
        hubsData.forEach(h => L.marker([h.lat, h.lng], {icon}).addTo(layers.hubs));
    }

    function drawPoints() {
        layers.points.clearLayers();
        pointsData.forEach(p => {
            const isSelected = selectedIds.has(p.id);
            const extraClass = isSelected ? 'selected-marker' : '';
            const icon = L.divIcon({
                className: '', 
                html: `<div class="pt-marker ${extraClass}" id="marker-${p.id}" style='background:${p.color}; width:10px; height:10px; border-radius:50%; border:1px solid #1e293b; transition:all 0.1s;'></div>`,
                iconSize: [12,12]
            });
            const m = L.marker([p.lat, p.lng], {icon});
            m.on('click', function(e) {
                if (selectionMode) togglePointSelection(p.id);
                else {
                    const popupContent = `
                        <b>${p.id}</b><br>
                        –°–î: ${p.assignedHub}<br>
                        –í–∞–≥–∞: ${p.load}<br>
                        –ì—Ä—É–ø–∞: <span style='font-size:1.2em; font-weight:bold'>${p.groupIndex}</span>
                        <hr style="border-color:#334155; margin:8px 0;">
                        <div class="popup-row">
                            <input type="number" id="m-${p.id}" value="${p.groupIndex}" style="width:60px">
                            <button class="small-btn" onclick="movePt('${p.id}')">OK</button>
                        </div>
                        <div class="popup-row" style="margin-top:8px">
                            <input type="number" id="mg-${p.id}" placeholder="‚Ññ" style="width:60px">
                            <button class="small-btn" onclick="mergeGr('${p.id}')">–ü–æ—î–¥–Ω–∞—Ç–∏</button>
                        </div>`;
                    L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
                }
            });
            m.addTo(layers.points);
        });
    }

    function drawBoundaries() {
        layers.polygons.clearLayers(); layers.labels.clearLayers();
        const gr = {};
        pointsData.forEach(p => {
            if(!p.assignedHub) return;
            const k = p.assignedHub + '_' + p.groupIndex;
            if(!gr[k]) gr[k] = {pts:[], c:p.color, i:p.groupIndex, load:0, count:0};
            gr[k].pts.push([p.lng, p.lat]);
            gr[k].load += p.load;
            gr[k].count += 1;
        });
        
        Object.values(gr).forEach(g => {
            if(g.pts.length < 1) return;
            const tp = turf.points(g.pts);
            if(g.pts.length >= 3) {
                const hull = turf.convex(tp);
                if(hull) L.geoJSON(hull, {style: {color:g.c, weight:2, fillOpacity:0.3}}).addTo(layers.polygons);
            }
            let cent = (g.pts.length>=3) ? turf.centerOfMass(turf.convex(tp)) : turf.center(tp);
            const cc = cent.geometry.coordinates;
            
            // Label with stats on hover/click
            const icon = L.divIcon({ className: 'group-label', html: g.i, iconSize:[20,20], iconAnchor:[10,10] });
            const labelMarker = L.marker([cc[1], cc[0]], {icon}).addTo(layers.labels);
            labelMarker.bindTooltip(`–ì—Ä—É–ø–∞ ${g.i}<br>–¢–æ—á–æ–∫: ${g.count}<br>–í–∞–≥–∞: ${g.load.toFixed(1)}`);
        });
    }

    function redrawMap() { drawPoints(); drawBoundaries(); }

    // --- UNDO/REDO & ACTIONS ---
    function saveState() {
        const snapshot = JSON.parse(JSON.stringify(pointsData));
        historyStack.push(snapshot);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        updateUndoUI();
    }
    window.undoLastAction = function() {
        if (historyStack.length === 0) return;
        pointsData = historyStack.pop();
        clearSelection(); redrawMap(); updateUndoUI();
    };
    function updateUndoUI() {
        const btn = document.getElementById('undoBtn');
        btn.disabled = historyStack.length === 0;
        btn.style.opacity = historyStack.length === 0 ? '0.5' : '1';
        btn.innerText = `‚Ü© –°–∫–∞—Å—É–≤–∞—Ç–∏ –¥—ñ—é` + (historyStack.length ? ` (${historyStack.length})` : '');
    }

    window.movePt = function(id) {
        const val = parseInt(document.getElementById('m-'+id).value);
        const p = pointsData.find(x => x.id === id);
        if(p && val) { saveState(); p.groupIndex = val; p.color = getColor(p.assignedHub, val); map.closePopup(); redrawMap(); }
    };
    window.mergeGr = function(id) {
        const pSrc = pointsData.find(x => x.id === id);
        const tIdx = parseInt(document.getElementById('mg-'+id).value);
        if(pSrc && tIdx && pSrc.groupIndex !== tIdx) {
            saveState();
            const tCol = getColor(pSrc.assignedHub, tIdx);
            const sHub = pSrc.assignedHub; const sGrp = pSrc.groupIndex;
            pointsData.forEach(p => { if(p.assignedHub === sHub && p.groupIndex === sGrp) { p.groupIndex = tIdx; p.color = tCol; }});
            map.closePopup(); redrawMap();
        }
    };
    window.moveSelectedPoints = function() {
        const targetGroup = parseInt(document.getElementById('bulkGroupInput').value);
        if (!targetGroup && targetGroup !== 0) return alert("–í–∫–∞–∂—ñ—Ç—å –≥—Ä—É–ø—É!");
        if (selectedIds.size === 0) return alert("–û–±–µ—Ä—ñ—Ç—å —Ç–æ—á–∫–∏!");
        saveState();
        const colorCache = {};
        pointsData.forEach(p => {
            if (!selectedIds.has(p.id)) return;
            const hub = p.assignedHub; const key = hub + '_' + targetGroup;
            if (!colorCache[key]) {
                const ex = pointsData.find(x => x.assignedHub === hub && x.groupIndex === targetGroup && !selectedIds.has(x.id));
                colorCache[key] = ex ? ex.color : getDistinctColor((hub.length + targetGroup) * 13);
            }
            p.groupIndex = targetGroup; p.color = colorCache[key];
        });
        clearSelection(); document.getElementById('bulkGroupInput').value = ''; redrawMap();
    };

    // --- UTILS ---
    function getColor(hid, gidx) {
        const ex = pointsData.find(p => p.assignedHub === hid && p.groupIndex === gidx);
        return ex ? ex.color : getDistinctColor((hid.length+gidx)*13);
    }
    function getDistinctColor(i) { return `hsl(${(i * 137.5) % 360}, 75%, 55%)`; }

    function toggleSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('btnSelectMode');
        const panel = document.getElementById('bulkActions');
        if (selectionMode) {
            btn.style.background = '#facc15'; btn.style.color = '#000';
            btn.innerText = '–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è (–í–ö–õ)';
            panel.style.display = 'block';
        } else {
            btn.style.background = ''; btn.style.color = '';
            btn.innerText = '–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è';
            if(selectedIds.size === 0) panel.style.display = 'none';
        }
    }
    function togglePointSelection(id) {
        const el = document.getElementById('marker-' + id);
        if (selectedIds.has(id)) { selectedIds.delete(id); if(el) el.classList.remove('selected-marker'); }
        else { selectedIds.add(id); if(el) el.classList.add('selected-marker'); }
        document.getElementById('selCount').innerText = selectedIds.size;
    }
    function clearSelection() {
        selectedIds.clear(); document.getElementById('selCount').innerText = 0;
        document.querySelectorAll('.selected-marker').forEach(el => el.classList.remove('selected-marker'));
        if(selectionMode) toggleSelectionMode();
        document.getElementById('bulkActions').style.display = 'none';
    }

    function exportToExcel() {
        if(!pointsData.length) return;
        const wsExport = XLSX.utils.json_to_sheet(pointsData.map(p => ({
            "ID":p.id, "Lat":p.lat, "Lng":p.lng, "Hub":p.assignedHub, "Group":p.groupIndex, "Load": p.load
        })));
        const wsSavedPoints = XLSX.utils.json_to_sheet(pointsData);
        const wsSavedHubs = XLSX.utils.json_to_sheet(hubsData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, wsExport, "Result_Export");
        XLSX.utils.book_append_sheet(wb, wsSavedPoints, "Saved_Points");
        XLSX.utils.book_append_sheet(wb, wsSavedHubs, "Saved_Hubs");
        XLSX.writeFile(wb, `Result.xlsx`);
    }

    document.querySelectorAll('input[type="number"]').forEach(input => {
        input.addEventListener('wheel', function(e) {
            e.preventDefault();
            const step = parseInt(this.getAttribute('step')) || 1;
            this.value = (parseInt(this.value) || 0) + (e.deltaY < 0 ? step : -step);
        }, { passive: false });
    });
</script>
</body>
</html>